<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OpenCT: ifd_driver_ops Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>ifd_driver_ops Struct Reference</h1>Driver operations.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="driver_8h-source.html">driver.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="o0" doxytag="ifd_driver_ops::default_protocol"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>default_protocol</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o1">open</a> )(ifd_reader_t *reader, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the reader.  <a href="#o1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o2">close</a> )(ifd_reader_t *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the reader.  <a href="#o2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o3">change_parity</a> )(ifd_reader_t *reader, int parity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the communication protocol parity.  <a href="#o3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o4">change_speed</a> )(ifd_reader_t *reader, unsigned int speed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the communication protocol speed.  <a href="#o4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o5">activate</a> )(ifd_reader_t *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate the smart card reader.  <a href="#o5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o6">deactivate</a> )(ifd_reader_t *reader)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deactivate the smart card reader.  <a href="#o6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o7">card_status</a> )(ifd_reader_t *reader, int slot, int *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the card status.  <a href="#o7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o8">card_reset</a> )(ifd_reader_t *reader, int slot, void *atr, size_t atr_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the card and fetch the ATR.  <a href="#o8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o9">card_request</a> )(ifd_reader_t *reader, int slot, time_t timeout, const char *message, void *atr, size_t atr_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prompts the insertion of a smart card in the reader and performs a card reset.  <a href="#o9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o10">card_eject</a> )(ifd_reader_t *reader, int slot, time_t timeout, const char *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eject the smart card.  <a href="#o10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o11">output</a> )(ifd_reader_t *reader, const char *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a message on the reader's display.  <a href="#o11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o12">perform_verify</a> )(ifd_reader_t *reader, int slot, unsigned int timeout, const char *prompt, const unsigned char *data, size_t data_len, unsigned char *resp, size_t resp_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the PIN and have the card verify it.  <a href="#o12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o13">send</a> )(ifd_reader_t *reader, unsigned int dad, const unsigned char *buffer, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an APDU using the currently selected protocol.  <a href="#o13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o14">recv</a> )(ifd_reader_t *reader, unsigned int dad, unsigned char *buffer, size_t len, long timeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an APDU response using the currently selected protocol.  <a href="#o14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o15">set_protocol</a> )(ifd_reader_t *reader, int slot, int protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select the smart card communication protocol.  <a href="#o15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o16">transparent</a> )(ifd_reader_t *reader, int slot, const void *sbuf, size_t slen, void *rbuf, size_t rlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transceive a protocol data unit.  <a href="#o16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o17">sync_read</a> )(ifd_reader_t *reader, int slot, int proto, unsigned short addr, unsigned char *rbuf, size_t rlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a synchronous smart card.  <a href="#o17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structifd__driver__ops.html#o18">sync_write</a> )(ifd_reader_t *reader, int slot, int proto, unsigned short addr, const unsigned char *sbuf, size_t slen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a synchronous smart card.  <a href="#o18"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Driver operations. 
<p>

<p>
Definition at line <a class="el" href="driver_8h-source.html#l00020">20</a> of file <a class="el" href="driver_8h-source.html">driver.h</a>.<hr><h2>Field Documentation</h2>
<a class="anchor" name="o5" doxytag="ifd_driver_ops::activate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o5">activate</a>)(ifd_reader_t *reader)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Activate the smart card reader. 
<p>
This function performs all necessary operations to activate the smart card reader. After activation, the reader must be able to accept card status commands (card_status).<p>
Reader activation is currently performed once at startup, before calling card_status in response to CT_CMD_STATUS (is it really needed, as the reader was activated at startup ?), and when probing for synchronous cards.<p>
Called by: ifd_activate. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o10" doxytag="ifd_driver_ops::card_eject"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o10">card_eject</a>)(ifd_reader_t *reader, int slot, time_t timeout, const char *message)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Eject the smart card. 
<p>
This function ejects the smart card or prompt the user to remove the card by displaying the message <em>message</em>. The optional parameter <em>timeout</em>, if not equal to zero, gives the card removal timeout in seconds.<p>
It is not clear if this function should deactivate the smart card first, or if the caller must deactivate the card before calling card_eject.<p>
Called by: ifd_card_eject. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o9" doxytag="ifd_driver_ops::card_request"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o9">card_request</a>)(ifd_reader_t *reader, int slot, time_t timeout, const char *message, void *atr, size_t atr_len)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prompts the insertion of a smart card in the reader and performs a card reset. 
<p>
This function prompts the user to insert a smart card in the reader. For card readers equipped with a display, the optional message message should be displayed to the user. The optional parameter timeout, if not equal to zero, gives the prompt timeout in seconds.<p>
If a card is inserted before the timeout elapses, the card is reset and the ATR is fetched. See card_reset for more information.<p>
Called by: ifd_card_request <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, length of the ATR if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o8" doxytag="ifd_driver_ops::card_reset"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o8">card_reset</a>)(ifd_reader_t *reader, int slot, void *atr, size_t atr_len)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the card and fetch the ATR. 
<p>
This function resets the smart card and reads the Answer To Reset (ATR). The ATR will be stored in the slot structure by OpenCT, so the driver <b>must not</b> store the ATR itself in the slot structure.<p>
When resetting the card, the driver is allowed to select a protocol. If no protocol is selected when this function returns (assuming it returns successfully), OpenCT will try to select the protocol automatically (see set_protocol).<p>
Called by: ifd_card_request. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, length of the ATR if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o7" doxytag="ifd_driver_ops::card_status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o7">card_status</a>)(ifd_reader_t *reader, int slot, int *status)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fetch the card status. 
<p>
This function returns the current card status for a given slot. status is a bitfield which currently accepts the following flags:<p>
<ul>
<li><code>IFD_CARD_PRESENT</code> (1) A card is present in the slot. </li>
<li><code>IFD_CARD_STATUS_CHANGED</code> (2) The slot status has changed since last call.</li>
</ul>
Beside using IFD_CARD_STATUS_CHANGED, OpenCT checks if the card status has changed by comparing the current status value with the previous status value. If the value of the IFD_CARD_PRESENT has changed, OpenCT will set the IFD_CARD_STATUS_CHANGED <b>on the client side</b>.<p>
On the server side, setting IFD_CARD_STATUS_CHANGED will also set atr_len to 0 for the given slot. As atr_len is only checked in ifd_protocol_select, and as that function is only called in ifd_card_request right after assigning a value to atr_len, this is currently pointless and a reader driver should <b>not</b> set IFD_CARD_STATUS_CHANGED if its only source of information is a change of the IFD_CARD_PRESENT flag between the current call and the previous one.<p>
Called by: ifd_card_status. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o3" doxytag="ifd_driver_ops::change_parity"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o3">change_parity</a>)(ifd_reader_t *reader, int parity)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the communication protocol parity. 
<p>
This function is only used for asynchronous smart cards with serial readers, and only if the reader doesn't auto-detect the protocol parity.<p>
Depending on the smart card communication protocol convention (either direct or inverse, see ISO-7816-3, 6.4), the communication between the reader and the smart card uses odd or even parity. If most readers handle smart card protocol convention transparently, the most simple ones map the smart card lines directly on the serial port or require the user to configure the reader according smart card communication protocol parity. For those readers, OpenCT will try both parities (starting with even) when reading the ATR.<p>
This function, if available, configures the reader and/or the serial port according to the smart card communication protocol parity. It is used by ifd_card_request only.<p>
Accepted values for <em>parity</em> are<p>
<ul>
<li><code>IFD_SERIAL_PARITY_ODD</code> (1) </li>
<li><code>IFD_SERIAL_PARITY_EVEN</code> (2)</li>
</ul>
Called by: ifd_card_request. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o4" doxytag="ifd_driver_ops::change_speed"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o4">change_speed</a>)(ifd_reader_t *reader, unsigned int speed)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the communication protocol speed. 
<p>
It is not clear if this function was intended to change the communication speed between the host and the reader, the reader and the smart card, or both, as it is currently not used (ifd_set_speed is never called).<p>
Called by: ifd_set_speed. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o2" doxytag="ifd_driver_ops::close"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o2">close</a>)(ifd_reader_t *reader)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the reader. 
<p>
This function frees all the resources allocated by *open. If made possible by the hardware, the reader and all its slots must be powered off.<p>
The device will be closed by ifd_close, and must <b>not</b> be closed by this function.<p>
OpenCT currently never calls ifd_close, so the close function if not used.<p>
Called by: ifd_close. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o6" doxytag="ifd_driver_ops::deactivate"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o6">deactivate</a>)(ifd_reader_t *reader)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deactivate the smart card reader. 
<p>
Reader deactivation is currently performed only when probing for synchronous cards. OpenCT deactivates and reactivates the reader before trying to access the card.<p>
Called by: ifd_deactivate. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o1" doxytag="ifd_driver_ops::open"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o1">open</a>)(ifd_reader_t *reader, const char *name)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open the reader. 
<p>
This function opens the device named <em>name</em> and initialize the reader structure. The slots' dad should be set here.<p>
OpenCT calls the open function once at startup.<p>
Called by: ifd_open. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o11" doxytag="ifd_driver_ops::output"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o11">output</a>)(ifd_reader_t *reader, const char *message)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output a message on the reader's display. 
<p>
Called by: ifd_output. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o12" doxytag="ifd_driver_ops::perform_verify"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o12">perform_verify</a>)(ifd_reader_t *reader, int slot, unsigned int timeout, const char *prompt, const unsigned char *data, size_t data_len, unsigned char *resp, size_t resp_len)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request the PIN and have the card verify it. 
<p>
This function prompts the user to enter his PIN code and have the smart card verify the code. The optional parameter <em>timeout</em>, if not equal to zero, gives the PIN request timeout.<p>
The two bytes status (SW1-SW2) is copied in the <em>resp</em> buffer. If the status indicates a known error (IFD_ERROR_USER_TIMEOUT, IFD_ERROR_USER_ABORT, IFD_ERROR_PIN_MISMATCH) the error code is returned. Otherwise the length of the response (2) is returned.<p>
Called by: ifd_perform_verify. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, size of the response (2) if success or unknown error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o14" doxytag="ifd_driver_ops::recv"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o14">recv</a>)(ifd_reader_t *reader, unsigned int dad, unsigned char *buffer, size_t len, long timeout)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an APDU response using the currently selected protocol. 
<p>
This function is called by all non-transparent protocols to receive an APDU response from a device. The device address is set by the <em>dad</em> parameter which takes the same values as for the send function.<p>
The <em>dad</em> parameter is currently unused by all drivers, even the Kaan driver which takes care to initialize it correctly in the open function.<p>
Called by: ifd_recv_response. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes received if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o13" doxytag="ifd_driver_ops::send"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o13">send</a>)(ifd_reader_t *reader, unsigned int dad, const unsigned char *buffer, size_t len)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an APDU using the currently selected protocol. 
<p>
This function is called by all non-transparent protocols to send an APDU to a device. The device address is set by the <em>dad</em> parameter which is one of<p>
<ul>
<li><code>IFD_DAD_HOST</code> (0) Host (PC) - what's the point ? </li>
<li><code>IFD_DAD_IFD</code> (1) The APDU is sent to the reader </li>
<li><code>IFD_DAD_ICC1</code> (2) The APDU is sent to the first smart card </li>
<li><code>IFD_DAD_ICC2</code> (3) The APDU is sent to the second smart card</li>
</ul>
The <em>dad</em> parameter is currently unused by all drivers, even the Kaan driver which takes care to initialize it correctly in the open function.<p>
Called by: ifd_send_command. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes sent if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o15" doxytag="ifd_driver_ops::set_protocol"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o15">set_protocol</a>)(ifd_reader_t *reader, int slot, int protocol)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Select the smart card communication protocol. 
<p>
The smart card communication protocol is selected by OpenCT when the card is reset (either by reset_card or request_card), and can be overriden by the user by sending a CT_CMD_SET_PROTOCOL command.<p>
OpenCT doesn't perform a PPS exchange with the card itself, but selects the first protocol offered by the ATR at reset time by calling set_protocol. If the reader performs the PPS exchange with the card, the selected protocol can be set manually by the driver (by setting slot-&gt;proto) and set_protocol will not be called.<p>
It is not clear what the side effects of CT_CMD_SET_PROTOCOL (should it reset the card ?) should be and if that function is used at all by applications. Isn't the default protocol good enough ? I would have thought that set_protocol was meant to be called only right after reset, to select the protocol and instruct the driver to perform a PPS exchange.<p>
Called by: ifd_set_protocol, ifd_select_protocol. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o17" doxytag="ifd_driver_ops::sync_read"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o17">sync_read</a>)(ifd_reader_t *reader, int slot, int proto, unsigned short addr, unsigned char *rbuf, size_t rlen)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read data from a synchronous smart card. 
<p>
This function writes <em>rlen</em> bytes to the smart card, starting at address <em>addr</em>. The <em>proto</em> parameter specifies the desired communication protocol. The driver must set the protocol before reading data, or return an error if the protocol is not supported.<p>
Called by: sync_read at proto-sync.c, sync_write at proto-sync.c. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes read if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o18" doxytag="ifd_driver_ops::sync_write"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o18">sync_write</a>)(ifd_reader_t *reader, int slot, int proto, unsigned short addr, const unsigned char *sbuf, size_t slen)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write data to a synchronous smart card. 
<p>
This function reads <em>slen</em> bytes from the smart card, starting at address <em>addr</em>. The <em>proto</em> parameter specifies the desired communication protocol. The driver must set the protocol before writing data, or return an error if the protocol is not supported.<p>
Called by: sync_write at proto-sync.c. <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, number of bytes written if success. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="o16" doxytag="ifd_driver_ops::transparent"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int(* <a class="el" href="structifd__driver__ops.html#o16">transparent</a>)(ifd_reader_t *reader, int slot, const void *sbuf, size_t slen, void *rbuf, size_t rlen)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transceive a protocol data unit. 
<p>
This function is used by the transparent protocol, when the driver and/or the reader accepts raw PDUs directly. When using the transparent protocol, the PDUs sent by the client are forwarded directly to the driver without being mangled by OpenCT. If the driver and/or the reader can't accept the PDUs directly (for instance when the reader doesn't support Case 4 APDUs in T=0 protocol), the driver should instanciate the appropriate protocol handler to pre-process the PDUs. In that case, the send and recv functions will be used instead of the transparent function.<p>
Called by: trans_transceive at proto-trans.c <dl compact><dt><b>Returns:</b></dt><dd>Error code &lt;0 if failure, size of the response if success. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="driver_8h-source.html">driver.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Aug 28 23:01:41 2005 for OpenCT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
